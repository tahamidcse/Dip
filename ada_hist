import matplotlib.pyplot as plt
import numpy as np
import cv2

height = 1000
width = 1000

def neg(img_gray):
    return 255-img_gray
def gamma(img_gray):
    c=1
    gama=0.5
    img=img_gray/255.0
    
    img_gamma = c*(img**gama)
    img_gamma = np.uint8(img_gamma * 255)
    return img_gamma
#================= Execution workflow ==============
def main():
    img_path = "/home/mohon/4_1/lab/dip_lab/images/runway.tif"
    img_gray = cv2.imread(img_path, 0)
    img_gray = cv2.resize(img_gray, (width*2, height*2))

    
    img_patches = img_patching(img_gray)
    patches_equalized = [histogram_equalization(img_patch) for img_patch in img_patches]
    patches_negative = [neg(img_patch) for img_patch in img_patches]
    patches_gama = [gamma(img_patch) for img_patch in img_patches]
    
    reconstructed_img = np.zeros((height*2, width*2), dtype=np.uint8)
    reconstructed_img[:height, :width] = patches_equalized[0]
    reconstructed_img[:height, width:] = patches_equalized[1]
    reconstructed_img[height:, :width] = patches_equalized[2]
    reconstructed_img[height:, width:] = patches_equalized[3]

    
    img_patches += [img_gray, reconstructed_img]
    title = ['patch-1', 'patch-2', 'patch-3', 'patch-4', 'original', 'equalized']
    display(img_patches, title)



        

def histogram_equalization(img_gray):
    #================= Histogram Equalization Pipeline =================
    hist = histogram(img_gray)                     # Original histogram
    pdf = pdf_f(hist)                              # Probability density function
    cdf = cdf_f(pdf)
    cdf_min = cdf[cdf > 0].min()
    cdf_normalized = ((cdf - cdf_min) * 255) / (cdf[-1] - cdf_min)                               # Cumulative distribution function
    new_level = np.round(np.array(cdf) * 255).astype(np.uint8)  # Mapping new intensity levels
    
    new_img = img_conv(img_gray, new_level)        # Apply mapping to image
    
    hist_e = histogram(new_img)  
    output = np.zeros_like(new_img)
    for intensity in range(256):
        map_layer = mappings[:, :, intensity]
        interp_map = cv2.resize(map_layer, (W, H), interpolation=cv2.INTER_LINEAR)
        mask = img_padded == intensity
        output[mask] = interp_map[mask]

    return output[:h, :w]                  # Histogram of equalized image


    return new_img

def img_patching(img_gray, number_of_patch = 4):
    

    
    h, w = img_gray.shape
    tile_h = h // noofpatch_h
    tile_w = w // noofpatch_w
    
    img_patches = []
    
    for i in range(noofpatch_h):
        for j in range(noofpatch_w):
            patch = img_gray[i*tile_h:(i+1)*tile_h, j*tile_w:(j+1)*tile_w]
            img_patches.append(patch)
    

    return img_patches

#================= Apply new intensity levels to image ================
def img_conv(img_gray, new_level):
    return new_level[img_gray]


#================= Function to calculate histogram ====================
def histogram(img_2D):
    h, w = img_2D.shape
    hist = np.zeros(256, dtype=int)

    for i in range(h):
        for j in range(w):
            pixel_value = img_2D[i, j]
            hist[pixel_value] += 1

    return hist

#================= Function to calculate PDF ==========================
def pdf_f(hist):
    return hist / hist.sum()

#================= Function to calculate CDF ==========================
def cdf_f(pdf):
    return np.cumsum(pdf)

#================= Display images and histograms ======================
def display(img_set, titles):
    plt.figure(figsize=(14, 10))  

    for i in range(len(img_set)):
        plt.subplot(3, 3, i + 1)
        if img_set[i].ndim == 2:
            plt.imshow(img_set[i], cmap="gray")    # Display image
            plt.axis('off')
        else:
            plt.bar(range(256), img_set[i])        # Display histogram or PDF/CDF
        plt.title(titles[i])

    plt.tight_layout()
    plt.show()

    
